#!/usr/bin/env python3
"""
Zeus ‚Äî Monitor and manage coding agents running in kitty windows.

Usage:
  zeus                              Live dashboard (default)
  zeus new -n NAME [-d DIR]         Launch a new tracked kitty window
  zeus ls                           One-shot text listing
  zeus focus <ID>                   Focus a kitty window (sway)
  zeus kill <ID>                    Close a kitty window
"""

import argparse
import json
import os
import re
import subprocess
import sys
import time
from dataclasses import dataclass, field
from enum import Enum
from glob import glob
from pathlib import Path
from typing import Optional

# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------

POLL_INTERVAL = float(os.environ.get("ZEUS_POLL", "2"))
NAMES_FILE = Path("/tmp/zeus-names.json")  # persisted rename overrides
USAGE_CACHE = Path("/tmp/claude-usage-cache.json")
OPENAI_USAGE_CACHE = Path("/tmp/openai-usage-cache.json")

# Pi spinner frames (from pi-tui Loader component)
SPINNER_RE = re.compile(r"[‚†ã‚†ô‚†π‚†∏‚†º‚†¥‚†¶‚†ß‚†á‚†è]\s+\S")

# Footer parsing (from usage-bars.ts extension output)
MODEL_RE = re.compile(r"^(\S+)\s*(?:\((\w+)\))?")
CTX_RE = re.compile(r"Ctx\([^)]*\):[‚ñà‚ñë]+\((\d+\.?\d*)%\)")
TOKENS_RE = re.compile(r"‚Üë([\d.]+[kM]?)\s+‚Üì([\d.]+[kM]?)")

# ---------------------------------------------------------------------------
# Data types
# ---------------------------------------------------------------------------

class State(str, Enum):
    WORKING = "WORKING"
    IDLE = "IDLE"


@dataclass
class TmuxSession:
    name: str
    command: str
    cwd: str
    created: int = 0           # unix timestamp
    attached: bool = False

@dataclass
class ProcessMetrics:
    cpu_pct: float = 0.0
    ram_mb: float = 0.0
    gpu_pct: float = 0.0
    gpu_mem_mb: float = 0.0
    io_read_bps: float = 0.0    # bytes/sec read (includes network)
    io_write_bps: float = 0.0   # bytes/sec write (includes network)

@dataclass
class AgentWindow:
    kitty_id: int
    socket: str
    name: str
    pid: int                    # shell PID inside kitty
    kitty_pid: int              # kitty process PID (from socket name)
    cwd: str
    state: State = State.IDLE
    model: str = ""
    ctx_pct: float = 0.0
    tokens_in: str = ""
    tokens_out: str = ""
    workspace: str = ""
    parent_name: str = ""         # ZEUS_PARENT env var (empty = top-level)
    tmux_sessions: list[TmuxSession] = field(default_factory=list)
    proc_metrics: ProcessMetrics = field(default_factory=ProcessMetrics)
    _screen_text: str = ""     # cached for tmux matching

@dataclass
class UsageData:
    session_pct: float = 0.0
    week_pct: float = 0.0
    extra_pct: float = 0.0
    extra_used: float = 0.0
    extra_limit: float = 0.0
    session_resets_at: str = ""
    week_resets_at: str = ""
    available: bool = False

@dataclass
class OpenAIUsageData:
    requests_pct: float = 0.0  # best-effort "session" approximation
    tokens_pct: float = 0.0    # best-effort "week" approximation
    requests_limit: int = 0
    requests_remaining: int = 0
    tokens_limit: int = 0
    tokens_remaining: int = 0
    requests_resets_at: str = ""
    tokens_resets_at: str = ""
    available: bool = False

# ---------------------------------------------------------------------------
# Per-process metrics (no dependencies, pure /proc + nvidia-smi)
# ---------------------------------------------------------------------------

# Per-process CPU tracking: pid -> (utime+stime, timestamp)
_prev_proc_cpu: dict[int, tuple[float, float]] = {}
# Per-process I/O tracking: pid -> (rchar, wchar, timestamp)
_prev_proc_io: dict[int, tuple[float, float, float]] = {}

def _fmt_bytes(bps: float) -> str:
    """Format bytes/sec into human-readable."""
    if bps >= 1048576:
        return f"{bps / 1048576:.1f}M"
    if bps >= 1024:
        return f"{bps / 1024:.0f}K"
    return f"{bps:.0f}B"

# ---------------------------------------------------------------------------
# Per-process metrics
# ---------------------------------------------------------------------------

def _get_process_tree(root_pid: int) -> list[int]:
    """Get all PIDs in the tree rooted at root_pid (inclusive)."""
    pids = [root_pid]
    try:
        children = subprocess.run(
            ["pgrep", "-P", str(root_pid)],
            capture_output=True, text=True, timeout=2)
        if children.returncode == 0:
            for line in children.stdout.strip().splitlines():
                try:
                    child = int(line.strip())
                    pids.extend(_get_process_tree(child))
                except ValueError:
                    pass
    except (subprocess.TimeoutExpired, FileNotFoundError):
        pass
    return pids

def _clk_tck() -> int:
    try:
        return os.sysconf("SC_CLK_TCK")
    except (ValueError, OSError):
        return 100

_CLK_TCK = _clk_tck()

def _read_proc_cpu(pids: list[int]) -> float:
    """Read total CPU ticks (utime+stime) for a set of PIDs."""
    total = 0.0
    for pid in pids:
        try:
            with open(f"/proc/{pid}/stat") as f:
                parts = f.read().split()
            total += float(parts[13]) + float(parts[14])  # utime + stime
        except (FileNotFoundError, IndexError, ValueError):
            pass
    return total

def _read_proc_ram(pids: list[int]) -> float:
    """Read total RSS in MB for a set of PIDs."""
    total = 0
    for pid in pids:
        try:
            with open(f"/proc/{pid}/statm") as f:
                pages = int(f.read().split()[1])  # RSS in pages
            total += pages
        except (FileNotFoundError, IndexError, ValueError):
            pass
    page_size = os.sysconf("SC_PAGE_SIZE") if hasattr(os, "sysconf") else 4096
    return total * page_size / 1048576  # MB

# Cache GPU pmon output per poll cycle
_gpu_pmon_cache: Optional[dict[int, tuple[float, float]]] = None
_gpu_pmon_ts: float = 0.0

def _read_gpu_pmon() -> dict[int, tuple[float, float]]:
    """Read nvidia-smi pmon, return {pid: (sm%, mem_mb)}. Cached per second."""
    global _gpu_pmon_cache, _gpu_pmon_ts
    now = time.time()
    if _gpu_pmon_cache is not None and now - _gpu_pmon_ts < 1.5:
        return _gpu_pmon_cache
    result: dict[int, tuple[float, float]] = {}
    try:
        r = subprocess.run(
            ["nvidia-smi", "pmon", "-c", "1", "-s", "u"],
            capture_output=True, text=True, timeout=3)
        if r.returncode == 0:
            for line in r.stdout.splitlines():
                if line.startswith("#") or not line.strip():
                    continue
                parts = line.split()
                if len(parts) >= 4:
                    try:
                        pid = int(parts[1])
                        sm = float(parts[3]) if parts[3] != "-" else 0.0
                        result[pid] = (sm, 0.0)
                    except (ValueError, IndexError):
                        pass
        # Also get per-process memory via compute-apps
        r2 = subprocess.run(
            ["nvidia-smi", "--query-compute-apps=pid,used_gpu_memory",
             "--format=csv,noheader,nounits"],
            capture_output=True, text=True, timeout=3)
        if r2.returncode == 0:
            for line in r2.stdout.strip().splitlines():
                parts = line.split(",")
                if len(parts) >= 2:
                    try:
                        pid = int(parts[0].strip())
                        mem = float(parts[1].strip())
                        sm = result.get(pid, (0.0, 0.0))[0]
                        result[pid] = (sm, mem)
                    except (ValueError, IndexError):
                        pass
    except (subprocess.TimeoutExpired, FileNotFoundError):
        pass
    _gpu_pmon_cache = result
    _gpu_pmon_ts = now
    return result

def read_process_metrics(kitty_pid: int) -> ProcessMetrics:
    """Read CPU%, RAM, GPU% for an agent's process tree."""
    global _prev_proc_cpu
    pids = _get_process_tree(kitty_pid)
    now = time.time()

    # CPU: delta-based
    ticks = _read_proc_cpu(pids)
    cpu_pct = 0.0
    prev = _prev_proc_cpu.get(kitty_pid)
    if prev is not None:
        dt = now - prev[1]
        if dt > 0:
            cpu_pct = ((ticks - prev[0]) / _CLK_TCK / dt) * 100
    _prev_proc_cpu[kitty_pid] = (ticks, now)

    # RAM
    ram_mb = _read_proc_ram(pids)

    # GPU: match any PID in tree
    gpu_data = _read_gpu_pmon()
    gpu_pct = 0.0
    gpu_mem = 0.0
    pid_set = set(pids)
    for pid, (sm, mem) in gpu_data.items():
        if pid in pid_set:
            gpu_pct += sm
            gpu_mem += mem

    # I/O: delta-based from /proc/<pid>/io (rchar/wchar includes network)
    global _prev_proc_io
    rchar = 0.0
    wchar = 0.0
    for pid in pids:
        try:
            with open(f"/proc/{pid}/io") as f:
                for line in f:
                    if line.startswith("rchar:"):
                        rchar += float(line.split()[1])
                    elif line.startswith("wchar:"):
                        wchar += float(line.split()[1])
        except (FileNotFoundError, PermissionError, IndexError, ValueError):
            pass
    io_read = 0.0
    io_write = 0.0
    prev_io = _prev_proc_io.get(kitty_pid)
    if prev_io is not None:
        dt = now - prev_io[2]
        if dt > 0:
            io_read = max(0, (rchar - prev_io[0]) / dt)
            io_write = max(0, (wchar - prev_io[1]) / dt)
    _prev_proc_io[kitty_pid] = (rchar, wchar, now)

    return ProcessMetrics(cpu_pct=cpu_pct, ram_mb=ram_mb, gpu_pct=gpu_pct, gpu_mem_mb=gpu_mem,
                          io_read_bps=io_read, io_write_bps=io_write)

# ---------------------------------------------------------------------------
# Session forking (for sub-agents)
# ---------------------------------------------------------------------------

AGENT_SESSIONS_DIR = Path.home() / ".pi" / "agent" / "sessions"

def _encode_session_dir(cwd: str) -> str:
    """Encode a cwd into pi's session directory name."""
    return f"--{cwd.lstrip('/').replace('/', '-').replace(':', '-')}--"

def find_current_session(cwd: str) -> Optional[str]:
    """Find the most recent session file for a given cwd."""
    session_dir = AGENT_SESSIONS_DIR / _encode_session_dir(cwd)
    if not session_dir.is_dir():
        return None
    files = sorted(
        [f for f in session_dir.iterdir() if f.suffix == ".jsonl"],
        key=lambda f: f.name, reverse=True)
    return str(files[0]) if files else None

def fork_session(source_path: str, target_cwd: str) -> Optional[str]:
    """Fork a pi session file into a new independent session (like pi's forkFrom).
    Returns the path to the new session file."""
    import uuid
    from datetime import datetime, timezone

    source = Path(source_path)
    if not source.exists():
        return None

    entries = []
    with open(source) as f:
        for line in f:
            line = line.strip()
            if line:
                try:
                    entries.append(json.loads(line))
                except json.JSONDecodeError:
                    continue
    if not entries:
        return None

    # Find header
    header = next((e for e in entries if e.get("type") == "session"), None)
    if not header:
        return None

    # Create new session file
    session_dir = AGENT_SESSIONS_DIR / _encode_session_dir(target_cwd)
    session_dir.mkdir(parents=True, exist_ok=True)

    new_id = str(uuid.uuid4())
    now = datetime.now(timezone.utc)
    ts = now.strftime("%Y-%m-%dT%H-%M-%S-") + f"{now.microsecond // 1000:03d}Z"
    new_file = session_dir / f"{ts}_{new_id}.jsonl"

    new_header = {
        "type": "session",
        "version": header.get("version", 3),
        "id": new_id,
        "timestamp": now.isoformat(),
        "cwd": target_cwd,
        "parentSession": source_path,
    }

    with open(new_file, "w") as f:
        f.write(json.dumps(new_header) + "\n")
        for entry in entries:
            if entry.get("type") != "session":
                f.write(json.dumps(entry) + "\n")

    return str(new_file)

# ---------------------------------------------------------------------------
# Kitty remote control
# ---------------------------------------------------------------------------

def kitty_cmd(socket: str, *args) -> Optional[str]:
    cmd = ["kitty", "@", "--to", f"unix:{socket}"] + list(args)
    try:
        r = subprocess.run(cmd, capture_output=True, text=True, timeout=3)
        if r.returncode == 0:
            return r.stdout
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError):
        pass
    return None

def _load_names() -> dict[str, str]:
    """Load rename overrides: {original_name: new_name}."""
    try:
        return json.loads(NAMES_FILE.read_text())
    except (FileNotFoundError, json.JSONDecodeError):
        return {}

def _save_names(names: dict[str, str]) -> None:
    NAMES_FILE.write_text(json.dumps(names))

def discover_sockets() -> list[str]:
    return glob("/tmp/kitty-*")

def discover_agents() -> list[AgentWindow]:
    agents = []
    for socket in discover_sockets():
        # Extract kitty PID from socket path: /tmp/kitty-{pid}
        try:
            kitty_pid = int(socket.rsplit("-", 1)[1])
        except (IndexError, ValueError):
            kitty_pid = 0
        raw = kitty_cmd(socket, "ls")
        if not raw:
            continue
        try:
            os_windows = json.loads(raw)
        except json.JSONDecodeError:
            continue
        for os_win in os_windows:
            for tab in os_win.get("tabs", []):
                for win in tab.get("windows", []):
                    env = win.get("env", {})
                    name = env.get("AGENTMON_NAME")

                    if not name:
                        # Auto-track plain pi windows without AGENTMON_NAME
                        cmdline = win.get("cmdline") or []
                        title = (win.get("title") or "").lower()
                        cmd_str = " ".join(str(x) for x in cmdline).lower()
                        looks_like_pi = (" pi" in f" {cmd_str} ") or (" pi" in title) or title.startswith("œÄ")
                        if not looks_like_pi:
                            continue
                        name = f"pi-{win['id']}"
                    agent_key = f"{socket}:{win['id']}"
                    agents.append(AgentWindow(
                        kitty_id=win["id"],
                        socket=socket,
                        name=name,
                        pid=win.get("pid", 0),
                        kitty_pid=kitty_pid,
                        cwd=win.get("cwd", ""),
                        parent_name=env.get("ZEUS_PARENT", ""),
                    ))
    # Apply name overrides and fix parent refs
    overrides = _load_names()
    # Build map: original_name -> new_name (for parent resolution)
    orig_to_new: dict[str, str] = {}
    for a in agents:
        key = f"{a.socket}:{a.kitty_id}"
        if key in overrides:
            orig_to_new[a.name] = overrides[key]
            a.name = overrides[key]
    # Resolve parent names through renames
    for a in agents:
        if a.parent_name and a.parent_name in orig_to_new:
            a.parent_name = orig_to_new[a.parent_name]
    return agents

def get_screen_text(agent: AgentWindow) -> str:
    text = kitty_cmd(agent.socket, "get-text", "--match", f"id:{agent.kitty_id}")
    return text or ""

def focus_window(agent: AgentWindow):
    subprocess.run(["swaymsg", f"[pid={agent.kitty_pid}]", "focus"],
                   capture_output=True, timeout=3)

def close_window(agent: AgentWindow):
    kitty_cmd(agent.socket, "close-window", "--match", f"id:{agent.kitty_id}")

def spawn_subagent(agent: AgentWindow, name: str) -> Optional[str]:
    """Fork the agent's session and launch a sub-agent in a new kitty window.
    Returns the forked session path, or None on failure."""
    cwd = agent.cwd
    source = find_current_session(cwd)
    if not source:
        return None
    forked = fork_session(source, cwd)
    if not forked:
        return None
    env = os.environ.copy()
    env["AGENTMON_NAME"] = name
    env["ZEUS_PARENT"] = agent.name
    subprocess.Popen(
        ["kitty", "--directory", cwd, "--hold",
         "bash", "-lc", f"pi --session {forked}"],
        env=env, start_new_session=True,
        stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
    )
    return forked

# ---------------------------------------------------------------------------
# Sway workspace discovery
# ---------------------------------------------------------------------------

def build_pid_workspace_map() -> dict[int, str]:
    try:
        r = subprocess.run(["swaymsg", "-t", "get_tree"],
                           capture_output=True, text=True, timeout=3)
        if r.returncode != 0:
            return {}
        tree = json.loads(r.stdout)
    except (subprocess.TimeoutExpired, json.JSONDecodeError):
        return {}

    pid_ws: dict[int, str] = {}
    def walk(node: dict, workspace: str = ""):
        if node.get("type") == "workspace":
            workspace = node.get("name", workspace)
        pid = node.get("pid")
        if pid:
            pid_ws[pid] = workspace
        for child in node.get("nodes", []) + node.get("floating_nodes", []):
            walk(child, workspace)
    walk(tree)
    return pid_ws

# ---------------------------------------------------------------------------
# Tmux session discovery
# ---------------------------------------------------------------------------

def discover_tmux_sessions() -> list[TmuxSession]:
    """Get all detached tmux sessions."""
    try:
        r = subprocess.run(
            ["tmux", "list-sessions", "-F",
             "#{session_name}\t#{session_attached}\t#{session_created}"],
            capture_output=True, text=True, timeout=3)
        if r.returncode != 0:
            return []
    except (subprocess.TimeoutExpired, FileNotFoundError):
        return []

    sessions = []
    for line in r.stdout.strip().splitlines():
        parts = line.split("\t")
        if len(parts) < 3:
            continue
        name, attached, created = parts[0], parts[1], parts[2]
        is_attached = attached != "0"

        # Get pane info for this session
        cmd_str, cwd = "", ""
        try:
            p = subprocess.run(
                ["tmux", "list-panes", "-t", name, "-F",
                 "#{pane_start_command}\t#{pane_current_path}"],
                capture_output=True, text=True, timeout=3)
            if p.returncode == 0 and p.stdout.strip():
                pinfo = p.stdout.strip().splitlines()[0].split("\t")
                cmd_str = pinfo[0] if len(pinfo) > 0 else ""
                cwd = pinfo[1] if len(pinfo) > 1 else ""
        except (subprocess.TimeoutExpired, FileNotFoundError):
            pass

        sessions.append(TmuxSession(
            name=name,
            command=cmd_str,
            cwd=cwd,
            created=int(created) if created.isdigit() else 0,
            attached=is_attached,
        ))
    return sessions

def match_tmux_to_agents(agents: list[AgentWindow], tmux_sessions: list[TmuxSession]):
    """Match detached tmux sessions to agents by checking screen text."""
    for sess in tmux_sessions:
        for agent in agents:
            if sess.name in agent._screen_text:
                agent.tmux_sessions.append(sess)
                break  # each session matches at most one agent

# ---------------------------------------------------------------------------
# State detection
# ---------------------------------------------------------------------------

def detect_state(screen: str) -> State:
    if SPINNER_RE.search(screen):
        return State.WORKING
    return State.IDLE

def parse_footer(screen: str) -> tuple[str, float, str, str]:
    model, ctx_pct, tokens_in, tokens_out = "", 0.0, "", ""
    for line in reversed(screen.splitlines()):
        stripped = line.strip()
        if not stripped:
            continue
        ctx_match = CTX_RE.search(stripped)
        if ctx_match:
            ctx_pct = float(ctx_match.group(1))
            model_match = MODEL_RE.match(stripped)
            if model_match:
                m = model_match.group(1)
                thinking = model_match.group(2) or ""
                m = re.sub(r"-2025\d{4}|-2026\d{4}", "", m).replace("claude-", "")
                model = f"{m} ({thinking})" if thinking else m
            tok_match = TOKENS_RE.search(stripped)
            if tok_match:
                tokens_in = tok_match.group(1)
                tokens_out = tok_match.group(2)
            break
    return model, ctx_pct, tokens_in, tokens_out

# ---------------------------------------------------------------------------
# Usage data
# ---------------------------------------------------------------------------

def _time_left(value: str) -> str:
    """Convert a reset timestamp or duration to a human-readable countdown."""
    if not value:
        return ""
    raw = value.strip()

    duration = re.match(r"^(\d+(?:\.\d+)?)(ms|s|m|h)?$", raw)
    if duration and "T" not in raw:
        amount = float(duration.group(1))
        unit = duration.group(2) or "s"
        if unit == "ms":
            secs = int(round(amount / 1000))
        elif unit == "m":
            secs = int(round(amount * 60))
        elif unit == "h":
            secs = int(round(amount * 3600))
        else:
            secs = int(round(amount))
        if secs <= 0:
            return "now"
        h, rem = divmod(secs, 3600)
        m, s = divmod(rem, 60)
        if h > 0:
            return f"{h}h{m:02d}m"
        if m > 0:
            return f"{m}m"
        return f"{s}s"

    try:
        from datetime import datetime, timezone
        resets = datetime.fromisoformat(raw)
        now = datetime.now(timezone.utc)
        delta = resets - now
        secs = int(delta.total_seconds())
        if secs <= 0:
            return "now"
        h, m = secs // 3600, (secs % 3600) // 60
        if h > 0:
            return f"{h}h{m:02d}m"
        return f"{m}m"
    except Exception:
        return ""

def read_usage() -> UsageData:
    try:
        data = json.loads(USAGE_CACHE.read_text())
        return UsageData(
            session_pct=data.get("five_hour", {}).get("utilization", 0),
            week_pct=data.get("seven_day", {}).get("utilization", 0),
            extra_pct=data.get("extra_usage", {}).get("utilization", 0),
            extra_used=data.get("extra_usage", {}).get("used_credits", 0),
            extra_limit=data.get("extra_usage", {}).get("monthly_limit", 0),
            session_resets_at=data.get("five_hour", {}).get("resets_at", ""),
            week_resets_at=data.get("seven_day", {}).get("resets_at", ""),
            available=True,
        )
    except (FileNotFoundError, json.JSONDecodeError, KeyError):
        return UsageData()


def _spawn_openai_fetch() -> None:
    """Spawn a helper process to fetch OpenAI usage.

    We don't exec() a partial copy of this file anymore (too brittle).
    Instead, call this script with a hidden CLI command.
    """
    try:
        zeus_path = str(Path(sys.argv[0]).expanduser().resolve())
        subprocess.Popen(
            ["python3", zeus_path, "fetch-openai-usage"],
            stdout=subprocess.DEVNULL,
            stderr=open("/tmp/zeus-openai-fetch.err", "a"),
        )
    except Exception as e:
        _openai_log(f"failed to spawn openai fetch helper: {e}")


def _openai_log(msg: str) -> None:
    try:
        ts = time.strftime("%Y-%m-%d %H:%M:%S")
        with open("/tmp/zeus-openai.log", "a") as f:
            f.write(f"[{ts}] {msg}\n")
    except Exception:
        pass


def _load_openai_access_token() -> str:
    auth_path = Path.home() / ".pi" / "agent" / "auth.json"
    try:
        data = json.loads(auth_path.read_text())
        token_info = data.get("openai-codex", {})
        token = token_info.get("access", "")
        expires = token_info.get("expires", 0)
        if token:
            _openai_log(
                f"loaded openai-codex oauth access token from {auth_path} (expires_ms={expires})"
            )
        if token and (not expires or expires > int(time.time() * 1000)):
            return token
        if token:
            _openai_log("oauth access token appears expired, trying anyway")
            return token
        _openai_log("no openai-codex access token present in auth.json")
    except Exception as e:
        _openai_log(f"failed to read {auth_path}: {e}")
    return ""


def fetch_openai_usage() -> None:
    """Fetch OpenAI usage.

    Prefer ChatGPT backend WHAM usage endpoint (Codex-style) which works for Plus.
    Fallback to api.openai.com rate-limit headers if an API key is present.
    """
    api_key = os.environ.get("OPENAI_API_KEY")
    if api_key:
        _openai_log("auth source: OPENAI_API_KEY env")

    if not api_key:
        try:
            for socket in glob("/tmp/kitty-*"):
                raw = subprocess.run(
                    ["kitty", "@", "--to", f"unix:{socket}", "ls"],
                    capture_output=True,
                    text=True,
                    timeout=2,
                ).stdout
                data = json.loads(raw) if raw else []
                for os_win in data:
                    for tab in os_win.get("tabs", []):
                        for win in tab.get("windows", []):
                            key = win.get("env", {}).get("OPENAI_API_KEY")
                            if key:
                                api_key = key
                                _openai_log(f"auth source: kitty window env (socket={socket})")
                                break
                        if api_key:
                            break
                    if api_key:
                        break
                if api_key:
                    break
        except Exception as e:
            _openai_log(f"failed to scan kitty env for OPENAI_API_KEY: {e}")

    if not api_key:
        api_key = _load_openai_access_token()
        if api_key:
            _openai_log("auth source: pi oauth token (~/.pi/agent/auth.json openai-codex.access)")

    if not api_key:
        _openai_log("no auth found (OPENAI_API_KEY or pi oauth)")
        return

    # 1) Try ChatGPT backend usage endpoint (Codex-style):
    #    https://chatgpt.com/backend-api/wham/usage
    #    https://chat.openai.com/backend-api/wham/usage
    try:
        import urllib.request
        import urllib.error

        token = api_key
        base_urls = [
            "https://chatgpt.com/backend-api",
            "https://chat.openai.com/backend-api",
        ]
        for base in base_urls:
            url = f"{base}/wham/usage"
            _openai_log(f"requesting {url}")
            req = urllib.request.Request(
                url,
                method="GET",
                headers={
                    "Authorization": f"Bearer {token}",
                    "User-Agent": "zeus",
                    "Content-Type": "application/json",
                },
            )
            try:
                with urllib.request.urlopen(req, timeout=5) as response:
                    body = response.read().decode(errors="replace")
                    data = json.loads(body)

                    # Best-effort parse. We only care about two windows.
                    rl = (data.get("rate_limit") or {})
                    primary = (rl.get("primary_window") or {})
                    secondary = (rl.get("secondary_window") or {})

                    def _pct(win: dict) -> float:
                        try:
                            return float(win.get("used_percent", 0.0))
                        except Exception:
                            return 0.0

                    def _reset_at(win: dict) -> str:
                        # codex uses int seconds epoch under reset_at.
                        ra = win.get("reset_at")
                        if ra is None:
                            return ""
                        try:
                            secs = int(ra)
                            # store as ISO for _time_left
                            from datetime import datetime, timezone
                            return datetime.fromtimestamp(secs, tz=timezone.utc).isoformat()
                        except Exception:
                            return str(ra)

                    cache_data = {
                        # map primary->"session" and secondary->"week" approximation
                        "requests_limit": int(primary.get("limit", 0) or 0),
                        "requests_remaining": int(primary.get("remaining", 0) or 0),
                        "tokens_limit": int(secondary.get("limit", 0) or 0),
                        "tokens_remaining": int(secondary.get("remaining", 0) or 0),
                        "requests_pct": _pct(primary),
                        "tokens_pct": _pct(secondary),
                        "requests_resets_at": _reset_at(primary),
                        "tokens_resets_at": _reset_at(secondary),
                        "timestamp": time.time(),
                        "source": url,
                    }
                    OPENAI_USAGE_CACHE.write_text(json.dumps(cache_data))
                    _openai_log(f"cached wham usage to {OPENAI_USAGE_CACHE}")
                    return
            except urllib.error.HTTPError as e:
                err_body = e.read(500).decode(errors="replace")
                _openai_log(f"HTTPError {e.code} from {url}: {err_body}")
            except Exception as e:
                _openai_log(f"fetch failed for {url}: {type(e).__name__}: {e}")

    except Exception as e:
        _openai_log(f"wham usage attempt failed: {type(e).__name__}: {e}")

    # 2) Fallback: API platform rate-limit headers (requires billed API key)
    try:
        import urllib.request
        import urllib.error

        url = "https://api.openai.com/v1/chat/completions"
        payload = {
            "model": "gpt-3.5-turbo",
            "messages": [{"role": "user", "content": "hi"}],
            "max_tokens": 1,
        }
        _openai_log(f"fallback requesting {url} to read rate limit headers")
        req = urllib.request.Request(
            url,
            data=json.dumps(payload).encode(),
            headers={
                "Authorization": f"Bearer {api_key}",
                "Content-Type": "application/json",
            },
        )
        with urllib.request.urlopen(req, timeout=5) as response:
            headers = response.headers
            req_limit = headers.get("x-ratelimit-limit-requests", "")
            tok_limit = headers.get("x-ratelimit-limit-tokens", "")
            cache_data = {
                "requests_limit": int(req_limit or 0),
                "requests_remaining": int(headers.get("x-ratelimit-remaining-requests", 0) or 0),
                "tokens_limit": int(tok_limit or 0),
                "tokens_remaining": int(headers.get("x-ratelimit-remaining-tokens", 0) or 0),
                "requests_resets_at": headers.get("x-ratelimit-reset-requests", ""),
                "tokens_resets_at": headers.get("x-ratelimit-reset-tokens", ""),
                "timestamp": time.time(),
                "source": url,
            }
            OPENAI_USAGE_CACHE.write_text(json.dumps(cache_data))
            _openai_log(f"cached api rate limits to {OPENAI_USAGE_CACHE}")
    except Exception as e:
        try:
            import urllib.error
            if isinstance(e, urllib.error.HTTPError):
                body = e.read(500).decode(errors="replace")
                _openai_log(f"fallback HTTPError {e.code}: {body}")
            else:
                _openai_log(f"fallback fetch failed: {type(e).__name__}: {e}")
        except Exception:
            _openai_log(f"fallback fetch failed: {type(e).__name__}: {e}")


_last_openai_fetch_attempt: float = 0.0


def read_openai_usage() -> OpenAIUsageData:
    """Read cached OpenAI usage. Cache is populated by background fetch."""
    global _last_openai_fetch_attempt

    def _maybe_fetch(reason: str, min_interval_s: float = 5.0) -> None:
        global _last_openai_fetch_attempt
        now = time.time()
        if now - _last_openai_fetch_attempt >= min_interval_s:
            _openai_log(f"triggering background fetch ({reason})")
            _last_openai_fetch_attempt = now
            _spawn_openai_fetch()

    try:
        data = json.loads(OPENAI_USAGE_CACHE.read_text())
    except (FileNotFoundError, json.JSONDecodeError, KeyError) as e:
        _openai_log(f"openai cache read failed: {type(e).__name__}: {e}")
        _maybe_fetch("cache-missing")
        return OpenAIUsageData()

    age = time.time() - data.get("timestamp", 0)
    if age > 10:
        _maybe_fetch(f"cache-stale age={age:.1f}s")

    req_limit = int(data.get("requests_limit", 0) or 0)
    req_remaining = int(data.get("requests_remaining", 0) or 0)
    tok_limit = int(data.get("tokens_limit", 0) or 0)
    tok_remaining = int(data.get("tokens_remaining", 0) or 0)

    # If wham/usage already provides percent fields, prefer those.
    if "requests_pct" in data:
        req_pct = float(data.get("requests_pct") or 0.0)
    else:
        req_pct = ((req_limit - req_remaining) / req_limit * 100) if req_limit > 0 else 0.0

    if "tokens_pct" in data:
        tok_pct = float(data.get("tokens_pct") or 0.0)
    else:
        tok_pct = ((tok_limit - tok_remaining) / tok_limit * 100) if tok_limit > 0 else 0.0

    available = (req_limit > 0 or tok_limit > 0 or req_pct > 0 or tok_pct > 0)
    if not available:
        _maybe_fetch("cache-present-but-empty")

    return OpenAIUsageData(
        requests_pct=req_pct,
        tokens_pct=tok_pct,
        requests_limit=req_limit,
        requests_remaining=req_remaining,
        tokens_limit=tok_limit,
        tokens_remaining=tok_remaining,
        requests_resets_at=data.get("requests_resets_at", ""),
        tokens_resets_at=data.get("tokens_resets_at", ""),
        available=available,
    )

# ---------------------------------------------------------------------------
# Notifications
# ---------------------------------------------------------------------------

def notify(title: str, body: str, urgency: str = "normal"):
    try:
        subprocess.run(["notify-send", f"--urgency={urgency}",
                        "--app-name=zeus", "-i", "utilities-terminal",
                        title, body], capture_output=True, timeout=5)
    except (subprocess.TimeoutExpired, FileNotFoundError):
        pass

# ---------------------------------------------------------------------------
# CLI: new
# ---------------------------------------------------------------------------

def cmd_new(args):
    name = args.name
    directory = os.path.expanduser(args.directory or os.getcwd())
    env = os.environ.copy()
    env["AGENTMON_NAME"] = name
    cmd = ["kitty", "--directory", directory, "--hold", "bash", "-lc", "pi"]
    subprocess.Popen(cmd, env=env, start_new_session=True,
                     stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    print(f"‚úì Launched \"{name}\" with pi in {directory}")

# ---------------------------------------------------------------------------
# CLI: ls
# ---------------------------------------------------------------------------

def cmd_ls(args):
    agents = discover_agents()
    if not agents:
        print("No tracked agents. Launch with: zeus new -n 'name'")
        return
    pid_ws = build_pid_workspace_map()
    for a in agents:
        screen = get_screen_text(a)
        a.state = detect_state(screen)
        a.model, a.ctx_pct, a.tokens_in, a.tokens_out = parse_footer(screen)
        a.workspace = pid_ws.get(a.kitty_pid, "?")
        cwd = a.cwd
        icon = {"WORKING": "‚ñ∂", "IDLE": "‚èπ"}[a.state.value]
        print(f"  {icon} [{a.kitty_id}] {a.name:16s} {a.state.value:7s}  "
              f"{a.model or '‚Äî':20s} Ctx:{a.ctx_pct:.0f}%  WS:{a.workspace:3s}  {cwd}")

# ---------------------------------------------------------------------------
# CLI: focus / kill
# ---------------------------------------------------------------------------

def cmd_focus(args):
    for a in discover_agents():
        if str(a.kitty_id) == args.id or a.name == args.id:
            focus_window(a)
            print(f"‚úì Focused \"{a.name}\"")
            return
    print(f"‚úó \"{args.id}\" not found"); sys.exit(1)

def cmd_kill(args):
    for a in discover_agents():
        if str(a.kitty_id) == args.id or a.name == args.id:
            close_window(a)
            print(f"‚úì Closed \"{a.name}\"")
            return
    print(f"‚úó \"{args.id}\" not found"); sys.exit(1)

# ---------------------------------------------------------------------------
# Dashboard (Textual TUI)
# ---------------------------------------------------------------------------

def cmd_dashboard(args):
    from textual.app import App, ComposeResult
    from textual.binding import Binding
    from textual.containers import Horizontal, Vertical
    from textual.reactive import reactive
    from textual.widgets import DataTable, Footer, Header, Static, Label, ProgressBar
    from textual.timer import Timer
    from textual import work
    from rich.text import Text

    # ‚îÄ‚îÄ Usage bar widget ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    class UsageBar(Static):
        """A labeled progress bar showing a percentage."""
        pct = reactive(0.0)
        label_text = reactive("")
        extra_text = reactive("")

        def __init__(self, label: str, **kwargs):
            super().__init__(**kwargs)
            self.label_text = label

        def render(self) -> Text:
            pct = self.pct
            width = 12
            filled = round((min(100, max(0, pct)) / 100) * width)
            if pct >= 90:
                color = "#ff3333"
            elif pct >= 80:
                color = "#ff8800"
            else:
                color = "#00d7d7"
            bar_empty = "#555555"

            # Keep layout stable: reserve fixed widths for percent + extra text.
            pct_str = f"{pct:.0f}%"
            pct_field = pct_str.rjust(4)  # "  0%" .. "100%"

            extra_width = 8
            extra = (self.extra_text or "")
            if extra:
                extra = f" {extra.ljust(extra_width)}"

            t = Text()
            t.append(f"{self.label_text} ", style="#447777")
            t.append("‚ñà" * filled, style=color)
            t.append("‚ñë" * (width - filled), style=bar_empty)
            t.append(f" {pct_field}", style=f"bold {color}")
            if extra:
                t.append(extra, style="#447777")
            return t

    # ‚îÄ‚îÄ Main app ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    CSS = """
    Screen {
        background: #000000;
    }

    #title-bar {
        dock: top;
        height: 1;
        background: #0a1a2a;
        color: #00d7d7;
        padding: 0 1;
    }

    #title-text {
        width: auto;
        color: #00d7d7;
        text-style: bold;
    }

    #title-clock {
        color: #555555;
    }

    #top-bars {
        dock: top;
        height: 2;
    }

    #usage-bar {
        height: 1;
        padding: 0 1;
        background: #050f15;
    }

    .usage-item {
        width: auto;
        margin: 0 2 0 0;
    }

    #table-container {
        background: #000000;
    }

    #agent-table {
        height: 1fr;
        margin: 1 1;
        background: #000000;
    }

    DataTable {
        height: 1fr;
        background: #000000;
    }

    DataTable > .datatable--cursor {
        background: #003a3a;
        color: #00d7d7;
        text-style: bold;
    }

    DataTable > .datatable--header {
        background: #0a1a2a;
        color: #00d7d7;
        text-style: bold;
    }

    DataTable > .datatable--even-row {
        background: #000000;
    }

    DataTable > .datatable--odd-row {
        background: #000000;
    }

    #status-line {
        dock: bottom;
        height: 1;
        padding: 0 1;
        background: #0a1a2a;
        color: #447777;
    }

    #openai-usage-bar {
        height: 1;
        padding: 0 1;
        background: #050f15;
    }

    #empty-message {
        width: 100%;
        height: auto;
        content-align: center middle;
        margin: 3 0;
        color: #447777;
    }
    """

    class ZeusApp(App):
        TITLE = "Zeus"
        DEFAULT_CSS = CSS
        BINDINGS = [
            Binding("q", "quit", "Quit"),
            Binding("escape", "quit", "Quit", show=False),
            Binding("enter", "focus_agent", "Focus Agent"),
            Binding("n", "new_agent", "New Agent"),
            Binding("s", "spawn_subagent", "Sub-Agent"),
            Binding("k", "kill_agent", "Kill Agent"),
            Binding("r", "rename", "Rename"),
            Binding("f5", "refresh", "Refresh", show=False),
        ]

        agents: list[AgentWindow] = []
        prev_states: dict[int, State] = {}
        idle_since: dict[int, float] = {}     # kitty_id -> timestamp when went idle
        idle_notified: set[int] = set()       # kitty_ids already notified

        def compose(self) -> ComposeResult:
            yield Horizontal(
                Label("‚ö° Zeus", id="title-text"),
                Static("", id="title-clock"),
                id="title-bar",
            )
            yield Vertical(
                Horizontal(
                    UsageBar("Claude Session:", classes="usage-item", id="usage-session"),
                    UsageBar("Week:", classes="usage-item", id="usage-week"),
                    UsageBar("Extra:", classes="usage-item", id="usage-extra"),
                    id="usage-bar",
                ),
                Horizontal(
                    UsageBar("OpenAI Session:", classes="usage-item", id="openai-session"),
                    UsageBar("Week:", classes="usage-item", id="openai-week"),
                    id="openai-usage-bar",
                ),
                id="top-bars",
            )
            yield Vertical(
                DataTable(id="agent-table"),
                id="table-container",
            )
            yield Static("", id="status-line")

        def on_mount(self) -> None:
            table = self.query_one("#agent-table", DataTable)
            table.cursor_type = "row"
            table.zebra_stripes = True
            table.add_columns("Name", "State", "Model", "Ctx", "CPU", "RAM", "GPU", "Net", "WS", "CWD", "Tokens")
            self.poll_and_update()
            self.set_interval(POLL_INTERVAL, self.poll_and_update)
            self.set_interval(1.0, self.update_clock)

        def update_clock(self) -> None:
            clock = self.query_one("#title-clock", Static)
            clock.update(f"  {time.strftime('%H:%M:%S')}")

        def poll_and_update(self) -> None:
            self.agents = discover_agents()
            pid_ws = build_pid_workspace_map()
            tmux_sessions = discover_tmux_sessions()

            # Proactively try to populate OpenAI cache early (throttled in read_openai_usage)
            _ = read_openai_usage()

            for a in self.agents:
                screen = get_screen_text(a)
                a._screen_text = screen
                a.state = detect_state(screen)
                a.model, a.ctx_pct, a.tokens_in, a.tokens_out = parse_footer(screen)
                a.workspace = pid_ws.get(a.kitty_pid, "?")
                a.proc_metrics = read_process_metrics(a.kitty_pid)

                # Notifications ‚Äî only after 4s of continuous idle
                old = self.prev_states.get(a.kitty_id)
                if a.state == State.IDLE:
                    if old == State.WORKING:
                        self.idle_since[a.kitty_id] = time.time()
                        self.idle_notified.discard(a.kitty_id)
                    elif a.kitty_id in self.idle_since and a.kitty_id not in self.idle_notified:
                        if time.time() - self.idle_since[a.kitty_id] >= 4.0:
                            notify("Agent ready", f"[{a.name}] needs attention", "critical")
                            self.idle_notified.add(a.kitty_id)
                else:
                    self.idle_since.pop(a.kitty_id, None)
                    self.idle_notified.discard(a.kitty_id)
                self.prev_states[a.kitty_id] = a.state

            match_tmux_to_agents(self.agents, tmux_sessions)

            # Update usage bars
            usage = read_usage()
            if usage.available:
                sess_bar = self.query_one("#usage-session", UsageBar)
                sess_bar.pct = usage.session_pct
                sess_left = _time_left(usage.session_resets_at)
                sess_bar.extra_text = f"({sess_left})" if sess_left else ""

                week_bar = self.query_one("#usage-week", UsageBar)
                week_bar.pct = usage.week_pct


                extra_bar = self.query_one("#usage-extra", UsageBar)
                extra_bar.pct = usage.extra_pct
                if usage.extra_limit > 0:
                    extra_bar.extra_text = f"${usage.extra_used / 100:.2f}/${usage.extra_limit / 100:.2f}"

            # Update OpenAI usage bars (Codex-style /wham/usage)
            openai = read_openai_usage()
            o_sess = self.query_one("#openai-session", UsageBar)
            o_week = self.query_one("#openai-week", UsageBar)
            if openai.available:
                o_sess.pct = openai.requests_pct
                left = _time_left(openai.requests_resets_at)
                o_sess.extra_text = f"({left})" if left else ""

                o_week.pct = openai.tokens_pct
                o_week.extra_text = ""
            else:
                o_sess.pct = 0
                o_sess.extra_text = "(unavailable)"
                o_week.pct = 0
                o_week.extra_text = ""

            # Update table
            table = self.query_one("#agent-table", DataTable)
            # Save selected row key before clearing
            _saved_key = self._get_selected_row_key()
            table.clear()

            if not self.agents:
                status = self.query_one("#status-line", Static)
                status.update("  No tracked agents ‚Äî press [bold]n[/] to create one, or open a terminal with $mod+Return and type a name")
                return

            # Separate top-level agents from sub-agents
            parent_names = {a.name for a in self.agents}
            top_level = [a for a in self.agents
                         if not a.parent_name or a.parent_name not in parent_names]
            children_of: dict[str, list[AgentWindow]] = {}
            for a in self.agents:
                if a.parent_name and a.parent_name in parent_names:
                    children_of.setdefault(a.parent_name, []).append(a)

            def _add_agent_row(a: AgentWindow, indent: str = ""):
                icon = {"WORKING": "‚ñ∂", "IDLE": "‚èπ"}[a.state.value]
                state_color = {"WORKING": "#00d7d7", "IDLE": "#ff3333"}[a.state.value]
                if indent:
                    name_text = Text(f"{indent}üß¨ {a.name}", style="#00d7d7")
                else:
                    name_text = a.name
                state_text = Text(f"{icon} {a.state.value}", style=f"bold {state_color}")
                ctx_str = f"{a.ctx_pct:.0f}%" if a.ctx_pct else "‚Äî"
                tok_str = f"‚Üë{a.tokens_in} ‚Üì{a.tokens_out}" if a.tokens_in else "‚Äî"

                pm = a.proc_metrics
                cpu_c = "#ff3333" if pm.cpu_pct >= 90 else "#ff8800" if pm.cpu_pct >= 50 else "#00d7d7"
                cpu_text = Text(f"{pm.cpu_pct:.0f}%", style=cpu_c)
                ram_text = Text(f"{pm.ram_mb:.0f}M", style="#00d7d7")
                gpu_c = "#ff3333" if pm.gpu_pct >= 90 else "#ff8800" if pm.gpu_pct >= 50 else "#00d7d7"
                gpu_str = f"{pm.gpu_pct:.0f}%"
                if pm.gpu_mem_mb > 0:
                    gpu_str += f" {pm.gpu_mem_mb:.0f}M"
                gpu_text = Text(gpu_str, style=gpu_c)
                net_str = f"‚Üì{_fmt_bytes(pm.io_read_bps)} ‚Üë{_fmt_bytes(pm.io_write_bps)}"
                net_text = Text(net_str, style="#00d7d7")

                row_key = f"{a.socket}:{a.kitty_id}"
                table.add_row(
                    name_text,
                    state_text,
                    a.model or "‚Äî",
                    ctx_str,
                    cpu_text,
                    ram_text,
                    gpu_text,
                    net_text,
                    a.workspace or "?",
                    a.cwd,
                    tok_str,
                    key=row_key,
                )

            def _add_tmux_rows(a: AgentWindow):
                for sess in a.tmux_sessions:
                    age_s = int(time.time()) - sess.created if sess.created else 0
                    if age_s >= 3600:
                        age_str = f"{age_s // 3600}h{(age_s % 3600) // 60}m"
                    elif age_s >= 60:
                        age_str = f"{age_s // 60}m"
                    else:
                        age_str = f"{age_s}s"
                    if sess.attached:
                        dim = "#334433"
                        tmux_name = Text(f"  ‚îî üîç {sess.name}", style=dim)
                        tmux_cmd = Text(sess.command[:30] or "‚Äî", style=dim)
                        tmux_age = Text(f"‚è± {age_str} ‚óè", style=dim)
                    else:
                        tmux_name = Text(f"  ‚îî üîç {sess.name}", style="#00d787")
                        tmux_cmd = Text(sess.command[:30] or "‚Äî", style="#557755")
                        tmux_age = Text(f"‚è± {age_str}", style="#557755")
                    tmux_key = f"tmux:{sess.name}"
                    table.add_row(
                        tmux_name,
                        tmux_age,
                        tmux_cmd,
                        "", "", "", "", "",
                        "",
                        sess.cwd,
                        "",
                        key=tmux_key,
                    )

            for a in top_level:
                _add_agent_row(a)
                # Sub-agents under parent
                for child in children_of.get(a.name, []):
                    _add_agent_row(child, indent="  ‚îî ")
                    _add_tmux_rows(child)
                # Tmux sessions of parent
                _add_tmux_rows(a)

            # Restore selected row
            if _saved_key:
                for idx, row_key in enumerate(table.rows):
                    if row_key.value == _saved_key:
                        table.move_cursor(row=idx)
                        break

            n_working = sum(1 for a in self.agents if a.state == State.WORKING)
            n_idle = sum(1 for a in self.agents if a.state == State.IDLE)
            status = self.query_one("#status-line", Static)
            status.update(
                f"  {len(self.agents)} agents  ‚îÇ  "
                f"[bold #00d7d7]{n_working} working[/]  "
                f"[bold #d7af00]{n_idle} idle[/]  ‚îÇ  "
                f"Poll: {POLL_INTERVAL}s"
            )

        def _get_selected_row_key(self) -> Optional[str]:
            table = self.query_one("#agent-table", DataTable)
            if table.row_count == 0:
                return None
            try:
                row_key, _ = table.coordinate_to_cell_key(table.cursor_coordinate)
                return row_key.value
            except Exception:
                return None

        def _get_selected_agent(self) -> Optional[AgentWindow]:
            key_val = self._get_selected_row_key()
            if not key_val or key_val.startswith("tmux:"):
                return None
            for a in self.agents:
                if f"{a.socket}:{a.kitty_id}" == key_val:
                    return a
            return None

        def _get_selected_tmux(self) -> Optional[TmuxSession]:
            key_val = self._get_selected_row_key()
            if not key_val or not key_val.startswith("tmux:"):
                return None
            sess_name = key_val[5:]  # strip "tmux:" prefix
            for a in self.agents:
                for sess in a.tmux_sessions:
                    if sess.name == sess_name:
                        return sess
            return None

        def action_focus_agent(self) -> None:
            agent = self._get_selected_agent()
            if agent:
                focus_window(agent)

        def _focus_tmux_client(self, sess: TmuxSession) -> bool:
            """Focus the sway window running an attached tmux session.
            Returns True if focused, False if not found."""
            try:
                r = subprocess.run(
                    ["tmux", "list-clients", "-t", sess.name, "-F", "#{client_pid}"],
                    capture_output=True, text=True, timeout=2)
                if r.returncode != 0 or not r.stdout.strip():
                    return False
                client_pid = int(r.stdout.strip().splitlines()[0])
                # Walk up ppid chain to find kitty process
                pid = client_pid
                for _ in range(10):
                    try:
                        with open(f"/proc/{pid}/comm") as f:
                            comm = f.read().strip()
                        if comm == "kitty":
                            subprocess.run(["swaymsg", f"[pid={pid}]", "focus"],
                                           capture_output=True, timeout=3)
                            return True
                        with open(f"/proc/{pid}/stat") as f:
                            ppid = int(f.read().split()[3])
                        if ppid <= 1:
                            break
                        pid = ppid
                    except (FileNotFoundError, ValueError, IndexError):
                        break
            except (subprocess.TimeoutExpired, ValueError):
                pass
            return False

        def _attach_tmux(self, sess: TmuxSession) -> None:
            """Handle Enter on a tmux row: focus if attached, open if detached."""
            if sess.attached:
                if self._focus_tmux_client(sess):
                    self.notify(f"Focused: {sess.name}", timeout=2)
                else:
                    self.notify(f"Could not find window for {sess.name}", timeout=2)
            else:
                subprocess.Popen(
                    ["kitty", "tmux", "attach", "-t", sess.name],
                    start_new_session=True,
                    stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                )
                self.notify(f"Attached: {sess.name}", timeout=2)

        def on_data_table_row_selected(self, event: DataTable.RowSelected) -> None:
            """Enter or click on a table row."""
            self._activate_selected_row()

        def _activate_selected_row(self) -> None:
            tmux = self._get_selected_tmux()
            if tmux:
                self._attach_tmux(tmux)
                return
            agent = self._get_selected_agent()
            if agent:
                focus_window(agent)
                self.notify(f"Focused: {agent.name}", timeout=2)

        _last_click_row: Optional[int] = None
        _last_click_time: float = 0.0

        def on_click(self, event) -> None:
            """Double click on a table row focuses the agent."""
            if event.chain < 2:
                return
            table = self.query_one("#agent-table", DataTable)
            w = event.widget
            if w is not table and table not in w.ancestors:
                return
            self.set_timer(0.05, self._activate_selected_row)

        def action_kill_agent(self) -> None:
            from textual.widgets import Input
            if isinstance(self.focused, Input):
                return  # Don't intercept k when typing in an input
            if len(self.screen_stack) > 1:
                return  # Don't fire when a modal is open
            agent = self._get_selected_agent()
            if agent:
                self.push_screen(ConfirmKillScreen(agent))

        def do_kill_agent(self, agent: AgentWindow) -> None:
            close_window(agent)
            notify("Agent closed", f"[{agent.name}] terminated")
            self.notify(f"Killed: {agent.name}", timeout=2)
            self.poll_and_update()

        def action_new_agent(self) -> None:
            self.push_screen(NewAgentScreen())

        def action_spawn_subagent(self) -> None:
            from textual.widgets import Input
            if isinstance(self.focused, Input):
                return
            if len(self.screen_stack) > 1:
                return
            agent = self._get_selected_agent()
            if not agent:
                self.notify("No agent selected", timeout=2)
                return
            session = find_current_session(agent.cwd)
            if not session:
                self.notify(f"No session found for {agent.name}", timeout=3)
                return
            self.push_screen(SubAgentScreen(agent))

        def do_spawn_subagent(self, agent: AgentWindow, name: str) -> None:
            result = spawn_subagent(agent, name)
            if result:
                notify("Sub-agent spawned", f"üß¨ [{name}] forked from [{agent.name}]")
                self.notify(f"üß¨ Spawned: {name}", timeout=3)
                self.set_timer(1.5, self.poll_and_update)
            else:
                self.notify(f"Failed to fork session for {agent.name}", timeout=3)

        def action_rename(self) -> None:
            from textual.widgets import Input
            if isinstance(self.focused, Input):
                return
            if len(self.screen_stack) > 1:
                return
            agent = self._get_selected_agent()
            if agent:
                self.push_screen(RenameScreen(agent))
                return
            tmux = self._get_selected_tmux()
            if tmux:
                self.push_screen(RenameTmuxScreen(tmux))

        def do_rename_agent(self, agent: AgentWindow, new_name: str) -> None:
            """Rename an agent via persistent name overrides."""
            overrides = _load_names()
            key = f"{agent.socket}:{agent.kitty_id}"
            overrides[key] = new_name
            _save_names(overrides)
            self.notify(f"Renamed: {agent.name} ‚Üí {new_name}", timeout=3)
            self.poll_and_update()

        def do_rename_tmux(self, sess: TmuxSession, new_name: str) -> None:
            """Rename a tmux session."""
            try:
                subprocess.run(
                    ["tmux", "rename-session", "-t", sess.name, new_name],
                    capture_output=True, timeout=3)
                self.notify(f"Renamed: {sess.name} ‚Üí {new_name}", timeout=3)
                self.poll_and_update()
            except Exception as e:
                self.notify(f"Rename failed: {e}", timeout=3)

        def action_refresh(self) -> None:
            self.poll_and_update()

    # ‚îÄ‚îÄ New agent dialog ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    from textual.screen import ModalScreen
    from textual.widgets import Input, Button

    NEW_AGENT_CSS = """
    NewAgentScreen {
        align: center middle;
    }

    #new-agent-dialog {
        width: 60;
        height: auto;
        max-height: 16;
        border: thick #00d7d7;
        background: #0a0a0a;
        padding: 1 2;
    }

    #new-agent-dialog Label {
        margin: 1 0 0 0;
        color: #00d7d7;
    }

    #new-agent-dialog Input {
        margin: 0 0 1 0;
    }

    #new-agent-buttons {
        height: 3;
        align: right middle;
        margin: 1 0 0 0;
    }

    #new-agent-buttons Button {
        margin: 0 0 0 1;
    }
    """

    class NewAgentScreen(ModalScreen):
        CSS = NEW_AGENT_CSS
        BINDINGS = [
            Binding("escape", "dismiss", "Cancel", show=False),
        ]

        def compose(self) -> ComposeResult:
            with Vertical(id="new-agent-dialog"):
                yield Label("New Agent")
                yield Label("Name:")
                yield Input(placeholder="e.g. fix-auth-bug", id="agent-name")
                yield Label("Directory:")
                yield Input(placeholder="e.g. /home/user/projects/backend", value=os.getcwd(), id="agent-dir")
                with Horizontal(id="new-agent-buttons"):
                    yield Button("Cancel", variant="default", id="cancel-btn")
                    yield Button("Launch", variant="primary", id="launch-btn")

        def on_button_pressed(self, event: Button.Pressed) -> None:
            if event.button.id == "launch-btn":
                self._launch()
            else:
                self.dismiss()

        def on_input_submitted(self, event: Input.Submitted) -> None:
            if event.input.id == "agent-name":
                self.query_one("#agent-dir", Input).focus()
            elif event.input.id == "agent-dir":
                self._launch()

        def _launch(self) -> None:
            name = self.query_one("#agent-name", Input).value.strip()
            directory = self.query_one("#agent-dir", Input).value.strip() or "."
            if not name:
                self.query_one("#agent-name", Input).focus()
                return
            directory = os.path.expanduser(directory)
            env = os.environ.copy()
            env["AGENTMON_NAME"] = name
            # Launch kitty and auto-start pi inside it
            subprocess.Popen(
                ["kitty", "--directory", directory, "--hold",
                 "bash", "-lc", "pi"],
                env=env, start_new_session=True,
                stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
            )
            self.dismiss()
            self.app.notify(f"Launched: {name} (pi)", timeout=3)
            # Delay refresh to let kitty start
            self.app.set_timer(1.5, self.app.poll_and_update)

    # ‚îÄ‚îÄ Sub-agent dialog ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    SUBAGENT_CSS = """
    SubAgentScreen {
        align: center middle;
    }

    #subagent-dialog {
        width: 60;
        height: auto;
        max-height: 12;
        border: thick #00d7d7;
        background: #0a0a0a;
        padding: 1 2;
    }

    #subagent-dialog Label {
        margin: 1 0 0 0;
        color: #00d7d7;
    }

    #subagent-dialog .dim-label {
        color: #447777;
        margin: 0;
    }

    #subagent-dialog Input {
        margin: 0 0 1 0;
    }

    #subagent-buttons {
        height: 3;
        align: right middle;
        margin: 1 0 0 0;
    }

    #subagent-buttons Button {
        margin: 0 0 0 1;
    }
    """

    class SubAgentScreen(ModalScreen):
        CSS = SUBAGENT_CSS
        BINDINGS = [
            Binding("escape", "dismiss", "Cancel", show=False),
        ]

        def __init__(self, agent: AgentWindow):
            super().__init__()
            self.agent = agent

        def compose(self) -> ComposeResult:
            with Vertical(id="subagent-dialog"):
                yield Label(f"üß¨ Fork sub-agent from [bold]{self.agent.name}[/bold]")
                yield Label(f"CWD: {self.agent.cwd}", classes="dim-label")
                yield Label("Name:")
                yield Input(
                    placeholder=f"e.g. {self.agent.name}-sub",
                    value=f"{self.agent.name}-sub",
                    id="subagent-name",
                )
                with Horizontal(id="subagent-buttons"):
                    yield Button("Cancel", variant="default", id="cancel-btn")
                    yield Button("üß¨ Fork", variant="primary", id="fork-btn")

        def on_button_pressed(self, event: Button.Pressed) -> None:
            if event.button.id == "fork-btn":
                self._fork()
            else:
                self.dismiss()

        def on_input_submitted(self, event: Input.Submitted) -> None:
            self._fork()

        def _fork(self) -> None:
            name = self.query_one("#subagent-name", Input).value.strip()
            if not name:
                self.query_one("#subagent-name", Input).focus()
                return
            self.dismiss()
            self.app.do_spawn_subagent(self.agent, name)

    # ‚îÄ‚îÄ Rename dialog ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    RENAME_CSS = """
    RenameScreen, RenameTmuxScreen {
        align: center middle;
    }

    #rename-dialog {
        width: 55;
        height: auto;
        border: solid #00d7d7;
        background: #0a0a0a;
        padding: 1 2;
    }

    #rename-dialog Label {
        margin: 0;
        color: #00d7d7;
    }

    #rename-dialog Input {
        margin: 1 0;
    }

    #rename-buttons {
        height: 3;
        align: right middle;
    }

    #rename-buttons Button {
        margin: 0 0 0 1;
    }
    """

    class RenameScreen(ModalScreen):
        CSS = RENAME_CSS
        BINDINGS = [Binding("escape", "dismiss", "Cancel", show=False)]

        def __init__(self, agent: AgentWindow):
            super().__init__()
            self.agent = agent

        def compose(self) -> ComposeResult:
            with Vertical(id="rename-dialog"):
                yield Label(f"Rename agent [bold]{self.agent.name}[/bold]")
                yield Label("New name:")
                yield Input(value=self.agent.name, id="rename-input")
                with Horizontal(id="rename-buttons"):
                    yield Button("Cancel", variant="default", id="cancel-btn")
                    yield Button("Rename", variant="primary", id="rename-btn")

        def on_mount(self) -> None:
            inp = self.query_one("#rename-input", Input)
            inp.focus()
            inp.action_select_all()

        def on_button_pressed(self, event: Button.Pressed) -> None:
            if event.button.id == "rename-btn":
                self._do_rename()
            else:
                self.dismiss()

        def on_input_submitted(self, event: Input.Submitted) -> None:
            self._do_rename()

        def _do_rename(self) -> None:
            new_name = self.query_one("#rename-input", Input).value.strip()
            if not new_name or new_name == self.agent.name:
                self.dismiss()
                return
            self.dismiss()
            self.app.do_rename_agent(self.agent, new_name)

    class RenameTmuxScreen(ModalScreen):
        CSS = RENAME_CSS
        BINDINGS = [Binding("escape", "dismiss", "Cancel", show=False)]

        def __init__(self, sess: TmuxSession):
            super().__init__()
            self.sess = sess

        def compose(self) -> ComposeResult:
            with Vertical(id="rename-dialog"):
                yield Label(f"Rename tmux session [bold]{self.sess.name}[/bold]")
                yield Label("New name:")
                yield Input(value=self.sess.name, id="rename-input")
                with Horizontal(id="rename-buttons"):
                    yield Button("Cancel", variant="default", id="cancel-btn")
                    yield Button("Rename", variant="primary", id="rename-btn")

        def on_mount(self) -> None:
            inp = self.query_one("#rename-input", Input)
            inp.focus()
            inp.action_select_all()

        def on_button_pressed(self, event: Button.Pressed) -> None:
            if event.button.id == "rename-btn":
                self._do_rename()
            else:
                self.dismiss()

        def on_input_submitted(self, event: Input.Submitted) -> None:
            self._do_rename()

        def _do_rename(self) -> None:
            new_name = self.query_one("#rename-input", Input).value.strip()
            if not new_name or new_name == self.sess.name:
                self.dismiss()
                return
            self.dismiss()
            self.app.do_rename_tmux(self.sess, new_name)

    # ‚îÄ‚îÄ Kill confirmation dialog ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    CONFIRM_KILL_CSS = """
    ConfirmKillScreen {
        align: center middle;
    }

    #confirm-kill-dialog {
        width: 50;
        height: auto;
        max-height: 10;
        border: thick #ff3366;
        background: #0a0a0a;
        padding: 1 2;
    }

    #confirm-kill-dialog Label {
        width: 100%;
        content-align: center middle;
        margin: 0 0 1 0;
        color: #cccccc;
    }

    #confirm-kill-buttons {
        height: 3;
        align: center middle;
    }

    #confirm-kill-buttons Button {
        margin: 0 1;
    }
    """

    class ConfirmKillScreen(ModalScreen):
        CSS = CONFIRM_KILL_CSS
        BINDINGS = [
            Binding("escape", "dismiss", "Cancel", show=False),
            Binding("y", "confirm", "Yes", show=False),
            Binding("n", "dismiss", "No", show=False),
        ]

        def __init__(self, agent: AgentWindow):
            super().__init__()
            self.agent = agent

        def compose(self) -> ComposeResult:
            with Vertical(id="confirm-kill-dialog"):
                yield Label(f"Kill agent [bold]{self.agent.name}[/bold]?")
                with Horizontal(id="confirm-kill-buttons"):
                    yield Button("No", variant="default", id="no-btn")
                    yield Button("Yes, kill", variant="error", id="yes-btn")

        def on_mount(self) -> None:
            self.query_one("#yes-btn", Button).focus()

        def on_button_pressed(self, event: Button.Pressed) -> None:
            if event.button.id == "yes-btn":
                self.app.do_kill_agent(self.agent)
            self.dismiss()

        def on_key(self, event) -> None:
            if event.key == "enter":
                self.app.do_kill_agent(self.agent)
                self.dismiss()

        def action_confirm(self) -> None:
            self.app.do_kill_agent(self.agent)
            self.dismiss()

    app = ZeusApp()
    app.run()

# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(prog="zeus",
        description="Monitor and manage coding agents in kitty windows")
    sub = parser.add_subparsers(dest="cmd")

    p_new = sub.add_parser("new", help="Launch a new tracked agent window")
    p_new.add_argument("-n", "--name", required=True, help="Agent name")
    p_new.add_argument("-d", "--directory", help="Working directory")
    p_new.set_defaults(func=cmd_new)

    p_ls = sub.add_parser("ls", help="List tracked agent windows")
    p_ls.set_defaults(func=cmd_ls)

    p_focus = sub.add_parser("focus", help="Focus an agent window")
    p_focus.add_argument("id", help="Window ID or name")
    p_focus.set_defaults(func=cmd_focus)

    p_kill = sub.add_parser("kill", help="Close an agent window")
    p_kill.add_argument("id", help="Window ID or name")
    p_kill.set_defaults(func=cmd_kill)

    # Hidden/internal command: used by the dashboard to refresh OpenAI limits
    p_fetch = sub.add_parser("fetch-openai-usage", help=argparse.SUPPRESS)
    p_fetch.set_defaults(func=lambda _args: fetch_openai_usage())

    p_dash = sub.add_parser("dashboard", aliases=["d"], help="Live dashboard")
    p_dash.set_defaults(func=cmd_dashboard)

    args = parser.parse_args()
    if hasattr(args, "func"):
        args.func(args)
    else:
        cmd_dashboard(args)

if __name__ == "__main__":
    main()
